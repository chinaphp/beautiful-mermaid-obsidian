/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BeautifulMermaidPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/renderer.ts
function clearElement(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}
function getGlobalProperty(name) {
  return window[name];
}
function hasFunctionProperty(value, prop) {
  if (typeof value !== "object" || value === null)
    return false;
  const record = value;
  return typeof record[prop] === "function";
}
var THEMES = {
  "tokyo-night": { bg: "#1a1b26", fg: "#a9b1d6", accent: "#7aa2f7" },
  "tokyo-night-storm": { bg: "#24283b", fg: "#a9b1d6", accent: "#7aa2f7" },
  "tokyo-night-light": { bg: "#d5d6db", fg: "#34548a", accent: "#34548a" },
  "catppuccin-mocha": { bg: "#1e1e2e", fg: "#cdd6f4", accent: "#cba6f7" },
  "catppuccin-latte": { bg: "#eff1f5", fg: "#4c4f69", accent: "#8839ef" },
  "nord": { bg: "#2e3440", fg: "#d8dee9", accent: "#88c0d0" },
  "nord-light": { bg: "#eceff4", fg: "#2e3440", accent: "#5e81ac" },
  "dracula": { bg: "#282a36", fg: "#f8f8f2", accent: "#bd93f9" },
  "github-dark": { bg: "#0d1117", fg: "#c9d1d9", accent: "#4493f8" },
  "github-light": { bg: "#ffffff", fg: "#24292f", accent: "#0969da" },
  "solarized-dark": { bg: "#002b36", fg: "#839496", accent: "#268bd2" },
  "solarized-light": { bg: "#fdf6e3", fg: "#657b83", accent: "#268bd2" },
  "one-dark": { bg: "#282c34", fg: "#abb2bf", accent: "#c678dd" },
  "zinc-dark": { bg: "#18181b", fg: "#a1a1aa", accent: "#27272a" },
  "zinc-light": { bg: "#ffffff", fg: "#27272a", accent: "#27272a" }
};
function applyThemeToSvg(svgElement, theme) {
  svgElement.style.setProperty("--bg", theme.bg);
  svgElement.style.setProperty("--fg", theme.fg);
  svgElement.style.setProperty("--line", theme.line || mixColor(theme.bg, theme.fg, 0.3));
  svgElement.style.setProperty("--accent", theme.accent || mixColor(theme.bg, theme.fg, 0.5));
  svgElement.style.setProperty("--muted", theme.muted || mixColor(theme.bg, theme.fg, 0.6));
  svgElement.style.setProperty("--surface", theme.surface || mixColor(theme.bg, theme.fg, 0.03));
  svgElement.style.setProperty("--border", theme.border || mixColor(theme.bg, theme.fg, 0.2));
  svgElement.style.backgroundColor = theme.bg;
  const textElements = svgElement.querySelectorAll("text, tspan");
  textElements.forEach((el) => {
    el.style.fill = theme.fg;
  });
  const strokeElements = svgElement.querySelectorAll("path, line, rect, circle, ellipse, polygon, polyline");
  strokeElements.forEach((el) => {
    const currentStroke = el.getAttribute("stroke");
    if (currentStroke && currentStroke !== "none" && !currentStroke.startsWith("#")) {
      el.style.stroke = theme.line || theme.fg;
    }
  });
  const fillElements = svgElement.querySelectorAll('rect[fill^="white"], circle[fill^="white"]');
  fillElements.forEach((el) => {
    const fillValue = theme.surface || mixColor(theme.bg, theme.fg, 0.03);
    el.setAttribute("fill", fillValue);
  });
}
function mixColor(bg, fg, ratio) {
  return ratio > 0.5 ? fg : bg;
}
async function renderBeautifulMermaid(source, container, themeName = "tokyo-night") {
  const theme = THEMES[themeName] || THEMES["tokyo-night"];
  clearElement(container);
  const beautifulMermaidCandidate = getGlobalProperty("beautifulMermaid");
  if (hasFunctionProperty(beautifulMermaidCandidate, "renderMermaid")) {
    try {
      const beautifulMermaid = beautifulMermaidCandidate;
      const svg = await beautifulMermaid.renderMermaid(source, theme);
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svg, "image/svg+xml");
      const svgElement = svgDoc.querySelector("svg");
      if (!svgElement)
        throw new Error("Failed to parse SVG from beautiful-mermaid");
      applyThemeToSvg(svgElement, theme);
      container.appendChild(svgElement);
      svgElement.classList.add("beautiful-mermaid-svg");
      return;
    } catch (error) {
      console.error("Beautiful Mermaid rendering failed:", error);
    }
  }
  const mermaidCandidate = getGlobalProperty("mermaid");
  if (hasFunctionProperty(mermaidCandidate, "initialize") && hasFunctionProperty(mermaidCandidate, "render")) {
    try {
      const cleanSource = source.trim();
      const id = "mermaid-" + Math.random().toString(36).slice(2, 11);
      const mermaid = mermaidCandidate;
      const mermaidTheme = themeName.includes("light") ? "default" : "dark";
      await mermaid.initialize({
        theme: mermaidTheme,
        securityLevel: "loose",
        startOnLoad: false
      });
      const { svg } = await mermaid.render(id, cleanSource);
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svg, "image/svg+xml");
      const svgElement = svgDoc.querySelector("svg");
      if (!svgElement)
        throw new Error("Failed to parse SVG from mermaid");
      container.appendChild(svgElement);
      applyThemeToSvg(svgElement, theme);
      svgElement.classList.add("beautiful-mermaid-svg");
      return;
    } catch (error) {
      console.error("Mermaid.js fallback failed:", error);
    }
  }
  const wrapper = document.createElement("div");
  wrapper.classList.add("beautiful-mermaid-missing");
  wrapper.style.setProperty("--bg", theme.bg);
  wrapper.style.setProperty("--fg", theme.fg);
  wrapper.style.setProperty("--border", theme.border || mixColor(theme.bg, theme.fg, 0.2));
  const p1 = document.createElement("p");
  p1.textContent = "Beautiful Mermaid plugin requires Mermaid to be enabled.";
  const p2 = document.createElement("p");
  p2.textContent = "Enable Obsidian's built-in Mermaid plugin in settings, or load Mermaid from an online source.";
  wrapper.appendChild(p1);
  wrapper.appendChild(p2);
  container.appendChild(wrapper);
}

// src/main.ts
var DEFAULT_SETTINGS = {
  theme: "tokyo-night",
  useDefaultMermaid: false
};
var BeautifulMermaidPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor(
      "mermaid",
      async (source, el, ctx) => {
        if (this.settings.useDefaultMermaid) {
          return;
        }
        try {
          await renderBeautifulMermaid(source, el, this.settings.theme);
        } catch (error) {
          console.error("Beautiful Mermaid error:", error);
          const errorDiv = document.createElement("div");
          errorDiv.classList.add("error");
          errorDiv.textContent = `Failed to render Mermaid diagram: ${String(error)}`;
          el.appendChild(errorDiv);
        }
      }
    );
    this.addSettingTab(new BeautifulMermaidSettingTab(this.app, this));
  }
  async loadSettings() {
    const loaded = await this.loadData();
    this.settings = { ...DEFAULT_SETTINGS, ...loaded != null ? loaded : {} };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var BeautifulMermaidSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Use default Mermaid").setDesc("Disable beautiful Mermaid and use Obsidian's built-in Mermaid renderer.").addToggle((toggle) => toggle.setValue(this.plugin.settings.useDefaultMermaid).onChange(async (value) => {
      this.plugin.settings.useDefaultMermaid = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Theme").setDesc("Select a theme for beautiful Mermaid diagrams.").addDropdown((dropdown) => dropdown.addOption("tokyo-night", "Tokyo night").addOption("tokyo-night-storm", "Tokyo night storm").addOption("catppuccin-mocha", "Catppuccin mocha").addOption("catppuccin-latte", "Catppuccin latte").addOption("nord", "Nord").addOption("nord-light", "Nord light").addOption("dracula", "Dracula").addOption("github-dark", "GitHub dark").addOption("github-light", "GitHub light").addOption("solarized-dark", "Solarized dark").addOption("solarized-light", "Solarized light").addOption("one-dark", "One dark").addOption("zinc-dark", "Zinc dark").addOption("zinc-light", "Zinc light").setValue(this.plugin.settings.theme).onChange(async (value) => {
      this.plugin.settings.theme = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("About").setDesc("Render diagrams with enhanced aesthetics and more than 15 built-in themes.").setHeading();
    new import_obsidian.Setting(containerEl).setName("Reload required").setDesc("After changing settings, reload note for changes to take effect.").setClass("mod-warning");
  }
};
