/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BeautifulMermaidPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/renderer.ts
var THEMES = {
  "tokyo-night": { bg: "#1a1b26", fg: "#a9b1d6", accent: "#7aa2f7" },
  "tokyo-night-storm": { bg: "#24283b", fg: "#a9b1d6", accent: "#7aa2f7" },
  "tokyo-night-light": { bg: "#d5d6db", fg: "#34548a", accent: "#34548a" },
  "catppuccin-mocha": { bg: "#1e1e2e", fg: "#cdd6f4", accent: "#cba6f7" },
  "catppuccin-latte": { bg: "#eff1f5", fg: "#4c4f69", accent: "#8839ef" },
  "nord": { bg: "#2e3440", fg: "#d8dee9", accent: "#88c0d0" },
  "nord-light": { bg: "#eceff4", fg: "#2e3440", accent: "#5e81ac" },
  "dracula": { bg: "#282a36", fg: "#f8f8f2", accent: "#bd93f9" },
  "github-dark": { bg: "#0d1117", fg: "#c9d1d9", accent: "#4493f8" },
  "github-light": { bg: "#ffffff", fg: "#24292f", accent: "#0969da" },
  "solarized-dark": { bg: "#002b36", fg: "#839496", accent: "#268bd2" },
  "solarized-light": { bg: "#fdf6e3", fg: "#657b83", accent: "#268bd2" },
  "one-dark": { bg: "#282c34", fg: "#abb2bf", accent: "#c678dd" },
  "zinc-dark": { bg: "#18181b", fg: "#a1a1aa", accent: "#27272a" },
  "zinc-light": { bg: "#ffffff", fg: "#27272a", accent: "#27272a" }
};
function applyThemeToSvg(svgElement, theme) {
  svgElement.style.setProperty("--bg", theme.bg);
  svgElement.style.setProperty("--fg", theme.fg);
  if (theme.line)
    svgElement.style.setProperty("--line", theme.line);
  if (theme.accent)
    svgElement.style.setProperty("--accent", theme.accent);
  if (theme.muted)
    svgElement.style.setProperty("--muted", theme.muted);
  if (theme.surface)
    svgElement.style.setProperty("--surface", theme.surface);
  if (theme.border)
    svgElement.style.setProperty("--border", theme.border);
  svgElement.style.backgroundColor = theme.bg;
  const textElements = svgElement.querySelectorAll("text, tspan");
  textElements.forEach((el) => {
    el.style.fill = theme.fg;
  });
  const strokeElements = svgElement.querySelectorAll("path, line, rect, circle, ellipse, polygon, polyline");
  strokeElements.forEach((el) => {
    const currentStroke = el.getAttribute("stroke");
    if (currentStroke && currentStroke !== "none" && !currentStroke.startsWith("#")) {
      el.style.stroke = theme.line || theme.fg;
    }
  });
  const fillElements = svgElement.querySelectorAll('rect[fill^="white"], circle[fill^="white"]');
  fillElements.forEach((el) => {
    const fillValue = theme.surface || mixColor(theme.bg, theme.fg, 0.03);
    el.setAttribute("fill", fillValue);
  });
}
function mixColor(bg, fg, ratio) {
  return ratio > 0.5 ? fg : bg;
}
async function renderBeautifulMermaid(source, container, themeName = "tokyo-night") {
  const theme = THEMES[themeName] || THEMES["tokyo-night"];
  container.innerHTML = "";
  if (window.beautifulMermaid) {
    try {
      const beautifulMermaid = window.beautifulMermaid;
      const svg = await beautifulMermaid.renderMermaid(source, theme);
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svg, "image/svg+xml");
      const rootElement = svgDoc.documentElement;
      if (rootElement && rootElement.tagName.toLowerCase() === "svg") {
        const svgElement = rootElement;
        applyThemeToSvg(svgElement, theme);
        const style = document.createElement("style");
        style.textContent = `
                    .beautiful-mermaid-svg {
                        --bg: ${theme.bg};
                        --fg: ${theme.fg};
                        --line: ${theme.line || mixColor(theme.bg, theme.fg, 0.3)};
                        --accent: ${theme.accent || mixColor(theme.bg, theme.fg, 0.5)};
                        --muted: ${theme.muted || mixColor(theme.bg, theme.fg, 0.6)};
                        --surface: ${theme.surface || mixColor(theme.bg, theme.fg, 0.03)};
                        --border: ${theme.border || mixColor(theme.bg, theme.fg, 0.2)};
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                    }
                    .beautiful-mermaid-svg text {
                        fill: var(--fg);
                    }
                    .beautiful-mermaid-svg path,
                    .beautiful-mermaid-svg line,
                    .beautiful-mermaid-svg rect,
                    .beautiful-mermaid-svg circle {
                        stroke: var(--line);
                    }
                    .beautiful-mermaid-svg .node rect {
                        fill: var(--surface);
                        stroke: var(--border);
                    }
                `;
        container.appendChild(style);
        container.appendChild(svgElement);
        svgElement.classList.add("beautiful-mermaid-svg");
        return;
      }
      throw new Error("Failed to parse SVG from beautiful-mermaid");
    } catch (error) {
      console.error("Beautiful Mermaid rendering failed:", error);
    }
  }
  if (window.mermaid) {
    try {
      const cleanSource = source.trim();
      const id = "mermaid-" + Math.random().toString(36).substr(2, 9);
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = `<pre class="mermaid">${cleanSource}</pre>`;
      container.appendChild(tempDiv);
      const mermaid = window.mermaid;
      const mermaidTheme = themeName.includes("light") ? "default" : "dark";
      await mermaid.initialize({
        theme: mermaidTheme,
        securityLevel: "loose",
        startOnLoad: false
      });
      const { svg } = await mermaid.render(id, cleanSource);
      container.innerHTML = svg;
      const svgElement = container.querySelector("svg");
      if (svgElement && svgElement.tagName === "svg") {
        applyThemeToSvg(svgElement, theme);
        svgElement.classList.add("beautiful-mermaid-svg");
      }
      return;
    } catch (error) {
      console.error("Mermaid.js fallback failed:", error);
    }
  }
  container.innerHTML = `
        <div style="padding: 20px; text-align: center; color: ${theme.fg}; background: ${theme.bg}; border-radius: 8px;">
            <p>\u26A0\uFE0F Beautiful Mermaid plugin requires mermaid.js to be loaded.</p>
            <p>Enable Obsidian's built-in Mermaid plugin in settings, or install via CDN.</p>
        </div>
    `;
}

// src/main.ts
var DEFAULT_SETTINGS = {
  theme: "tokyo-night",
  useDefaultMermaid: false
};
var BeautifulMermaidPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor(
      "mermaid",
      async (source, el, ctx) => {
        if (this.settings.useDefaultMermaid) {
          return;
        }
        try {
          await renderBeautifulMermaid(source, el, this.settings.theme);
        } catch (error) {
          console.error("Beautiful Mermaid error:", error);
          el.innerHTML = `<div class="error">Failed to render Mermaid diagram: ${error}</div>`;
        }
      }
    );
    this.addSettingTab(new BeautifulMermaidSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var BeautifulMermaidSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Use Default Mermaid").setDesc("Disable Beautiful Mermaid and use Obsidian's built-in Mermaid renderer").addToggle((toggle) => toggle.setValue(this.plugin.settings.useDefaultMermaid).onChange(async (value) => {
      this.plugin.settings.useDefaultMermaid = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Theme").setDesc("Select a theme for Beautiful Mermaid diagrams").addDropdown((dropdown) => dropdown.addOption("tokyo-night", "Tokyo Night").addOption("tokyo-night-storm", "Tokyo Night Storm").addOption("catppuccin-mocha", "Catppuccin Mocha").addOption("catppuccin-latte", "Catppuccin Latte").addOption("nord", "Nord").addOption("nord-light", "Nord Light").addOption("dracula", "Dracula").addOption("github-dark", "GitHub Dark").addOption("github-light", "GitHub Light").addOption("solarized-dark", "Solarized Dark").addOption("solarized-light", "Solarized Light").addOption("one-dark", "One Dark").addOption("zinc-dark", "Zinc Dark").addOption("zinc-light", "Zinc Light").setValue(this.plugin.settings.theme).onChange(async (value) => {
      this.plugin.settings.theme = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("About").setDesc("Beautiful Mermaid uses lukilabs/beautiful-mermaid to render beautiful diagrams with enhanced aesthetics and 15+ built-in themes.").setHeading();
    new import_obsidian.Setting(containerEl).setName("Reload Required").setDesc("After changing settings, reload note for changes to take effect.").setClass("mod-warning");
  }
};
